rules_version='2'

service cloud.firestore {
  match /databases/{database}/documents {
    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Helper function to check if user owns the document
    function isOwner(userId) {
      return request.auth.uid == userId;
    }
    
    // Helper function to check if user is accessing their own data
    function isOwnData() {
      return request.auth.uid == resource.data.userId;
    }
    
    // Users collection - allow authenticated users to read all profiles (for messaging/connections)
    match /users/{userId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && isOwner(userId);
      allow update: if isAuthenticated() && isOwner(userId);
      allow delete: if isAuthenticated() && isOwner(userId);
    }
    
    // Skill posts collection - users can read all posts, write their own
    match /skill_posts/{postId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update: if isAuthenticated() && isOwnData();
      allow delete: if isAuthenticated() && isOwnData();
    }
    
    // SIMPLIFIED CONNECTIONS RULES FOR DEBUGGING
    // Document ID should equal canonicalPair(senderId, recipientId) => minUid_maxUid
    function canonicalPair(u1, u2) {
      return (u1 < u2 ? u1 : u2) + '_' + (u1 < u2 ? u2 : u1);
    }

    match /connections/{connectionId} {
      // Allow read if current user is a participant in the connection
      allow read: if isAuthenticated() && (
        resource.data.senderId == request.auth.uid ||
        resource.data.recipientId == request.auth.uid
      );

      // SIMPLIFIED CREATE RULE: Just check that user is authenticated and is the sender
      allow create: if isAuthenticated() &&
        request.resource.data.senderId == request.auth.uid &&
        request.resource.data.recipientId != request.auth.uid &&
        request.resource.data.keys().hasAll(['senderId', 'recipientId', 'status', 'createdAt']);

      // SIMPLIFIED UPDATE RULE: Allow if user is participant
      allow update: if isAuthenticated() && (
        resource.data.senderId == request.auth.uid ||
        resource.data.recipientId == request.auth.uid
      );

      // Deleting connections is not allowed via client
      allow delete: if false;
    }
    
    // Enhanced Messages collection - for real-time messaging
    match /messages/{messageId} {
      allow read: if isAuthenticated() && (
        resource.data.senderId == request.auth.uid || 
        resource.data.receiverId == request.auth.uid
      );
      allow create: if isAuthenticated() && 
        request.resource.data.senderId == request.auth.uid &&
        request.resource.data.receiverId != request.auth.uid;
      allow update: if isAuthenticated() && (
        resource.data.receiverId == request.auth.uid || // Can mark as read
        (resource.data.senderId == request.auth.uid && 
         request.resource.data.keys().hasOnly(['content', 'editedAt', 'metadata'])) // Can edit own messages
      );
      allow delete: if isAuthenticated() && resource.data.senderId == request.auth.uid;
    }
    
    // Conversations collection - for organizing messages
    match /conversations/{conversationId} {
      allow read: if isAuthenticated() && 
        request.auth.uid in resource.data.participants;
      allow create: if isAuthenticated() && 
        request.auth.uid in request.resource.data.participants;
      allow update: if isAuthenticated() && 
        request.auth.uid in resource.data.participants;
    }
    
    // Chat messages - temporary permissive rules for testing
    match /chats/{chatId}/messages/{messageId} {
      // Allow all operations for authenticated users (temporary for testing)
      allow read, write: if isAuthenticated();
    }
    
    // Friends collection - for storing accepted connections
    match /friends/{friendId} {
      allow read: if isAuthenticated() && (
        resource.data.userId1 == request.auth.uid ||
        resource.data.userId2 == request.auth.uid
      );
      allow create: if isAuthenticated();
      allow update: if isAuthenticated() && (
        resource.data.userId1 == request.auth.uid ||
        resource.data.userId2 == request.auth.uid
      );
      allow delete: if isAuthenticated() && (
        resource.data.userId1 == request.auth.uid ||
        resource.data.userId2 == request.auth.uid
      );
    }
    
    // Sessions collection - users can manage sessions they're part of
    match /sessions/{sessionId} {
      allow read: if isAuthenticated() && (
        resource.data.organizerId == request.auth.uid ||
        resource.data.participantId == request.auth.uid
      );
      allow create: if isAuthenticated() && (
        request.resource.data.organizerId == request.auth.uid ||
        request.resource.data.participantId == request.auth.uid
      );
      allow update: if isAuthenticated() && (
        resource.data.organizerId == request.auth.uid ||
        resource.data.participantId == request.auth.uid
      );
      allow delete: if isAuthenticated() && (
        resource.data.organizerId == request.auth.uid ||
        resource.data.participantId == request.auth.uid
      );
    }
    
    // Session invitations collection - for session requests between users
    match /session_invitations/{invitationId} {
      allow read: if isAuthenticated() && (
        resource.data.senderId == request.auth.uid ||
        resource.data.receiverId == request.auth.uid
      );
      allow create: if isAuthenticated() && request.resource.data.senderId == request.auth.uid;
      allow update: if isAuthenticated() && (
        resource.data.senderId == request.auth.uid ||
        resource.data.receiverId == request.auth.uid
      );
      allow delete: if isAuthenticated() && (
        resource.data.senderId == request.auth.uid ||
        resource.data.receiverId == request.auth.uid
      );
    }
    
    // Notifications collection - for real-time notifications system
    match /notifications/{notificationId} {
      // Users can read their own notifications (as recipient)
      allow read: if isAuthenticated() && resource.data.recipientId == request.auth.uid;

      // Users can create notifications for others (as sender) when creating a connection request
      allow create: if isAuthenticated() &&
        request.resource.data.senderId == request.auth.uid &&
        request.resource.data.recipientId != request.auth.uid &&
        // Minimal schema constraints
        request.resource.data.keys().hasAny(['type', 'recipientId', 'senderId', 'message', 'createdAt']);

      // Users can update notifications they received (mark as read, update status)
      allow update: if isAuthenticated() && resource.data.recipientId == request.auth.uid;

      // Users can delete their own notifications
      allow delete: if isAuthenticated() && resource.data.recipientId == request.auth.uid;
    }
  }
}
